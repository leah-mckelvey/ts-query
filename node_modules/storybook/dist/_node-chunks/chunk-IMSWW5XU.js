import CJS_COMPAT_NODE_URL_u12tm8drdom from 'node:url';
import CJS_COMPAT_NODE_PATH_u12tm8drdom from 'node:path';
import CJS_COMPAT_NODE_MODULE_u12tm8drdom from "node:module";

var __filename = CJS_COMPAT_NODE_URL_u12tm8drdom.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_u12tm8drdom.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_u12tm8drdom.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------

// src/telemetry/event-cache.ts
import { cache } from "storybook/internal/common";
var operation = Promise.resolve(), setHelper = async (eventType, body) => {
  let lastEvents = await cache.get("lastEvents") || {};
  lastEvents[eventType] = { body, timestamp: Date.now() }, await cache.set("lastEvents", lastEvents);
}, set = async (eventType, body) => (await operation, operation = setHelper(eventType, body), operation);
var getLastEvents = async () => (await operation, await cache.get("lastEvents") || {}), upgradeFields = (event) => {
  let { body, timestamp } = event;
  return {
    timestamp,
    eventType: body?.eventType,
    eventId: body?.eventId,
    sessionId: body?.sessionId
  };
}, UPGRADE_EVENTS = ["init", "upgrade"], RUN_EVENTS = ["build", "dev", "error"], lastEvent = (lastEvents, eventTypes) => {
  let descendingEvents = eventTypes.map((eventType) => lastEvents?.[eventType]).filter(Boolean).sort((a, b) => b.timestamp - a.timestamp);
  return descendingEvents.length > 0 ? descendingEvents[0] : void 0;
}, getPrecedingUpgrade = async (events = void 0) => {
  let lastEvents = events || await cache.get("lastEvents") || {}, lastUpgradeEvent = lastEvent(lastEvents, UPGRADE_EVENTS), lastRunEvent = lastEvent(lastEvents, RUN_EVENTS);
  if (lastUpgradeEvent)
    return !lastRunEvent?.timestamp || lastUpgradeEvent.timestamp > lastRunEvent.timestamp ? upgradeFields(lastUpgradeEvent) : void 0;
};

// ../node_modules/nanoid/index.js
import { randomFillSync } from "crypto";

// ../node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128, pool, poolOffset, fillPool = (bytes) => {
  !pool || pool.length < bytes ? (pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER), randomFillSync(pool), poolOffset = 0) : poolOffset + bytes > pool.length && (randomFillSync(pool), poolOffset = 0), poolOffset += bytes;
};
var nanoid = (size = 21) => {
  fillPool(size -= 0);
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++)
    id += urlAlphabet[pool[i] & 63];
  return id;
};

// src/telemetry/session-id.ts
import { cache as cache2 } from "storybook/internal/common";
var SESSION_TIMEOUT = 1e3 * 60 * 60 * 2, sessionId;
var getSessionId = async () => {
  let now = Date.now();
  if (!sessionId) {
    let session = await cache2.get("session");
    session && session.lastUsed >= now - SESSION_TIMEOUT ? sessionId = session.id : sessionId = nanoid();
  }
  return await cache2.set("session", { id: sessionId, lastUsed: now }), sessionId;
};

export {
  nanoid,
  set,
  getLastEvents,
  getPrecedingUpgrade,
  getSessionId
};
